use dep::std;

// Applies basic constraints such that the subject's birthdate is
// never after the required birthdate.
fn check_claim(
    required_birthyear: Field,
    required_birthmonth: Field,
    required_birthday: Field,
    subject_birthyear: Field,
    subject_birthmonth: Field,
    subject_birthday: Field,
) {
    constrain required_birthyear as u16 >= subject_birthyear as u16;
    if (required_birthyear == subject_birthyear) {
        constrain required_birthmonth as u8 >= subject_birthmonth as u8;
        if (required_birthmonth == subject_birthmonth) {
            constrain required_birthday as u8 >= subject_birthday as u8;
        }
    }
}

// Constructs a payload for the issuer to sign, claiming that
// the subject was born on the given date.
fn construct_claim_payload(
    subject: Field,
    birthyear: Field,
    birthmonth : Field,
    birthday : Field,
) -> [u8; 32] {
    let h1 = std::hash::pedersen([subject, birthyear, birthmonth, birthday])[0];
    let h2 = h1.to_be_bytes(32);
    let mut result = [0; 32];
    for i in 0..32 {
        result[i] = h2[i];
    }
    result
}

fn main(
    required_birthyear: pub Field,
    required_birthmonth: pub Field,
    required_birthday: pub Field,
    issuer_public_key_x: pub [u8; 32],
    issuer_public_key_y: pub [u8; 32],
    issuer_signature: [u8; 64],
    subject: pub Field,
    subject_birthyear: Field,
    subject_birthmonth: Field,
    subject_birthday: Field,
) -> pub bool {
    check_claim(
        required_birthyear,
        required_birthmonth,
        required_birthday,
        subject_birthyear,
        subject_birthmonth,
        subject_birthday,
    );

    let claim_payload = construct_claim_payload(
        subject,
        subject_birthyear,
        subject_birthmonth,
        subject_birthday,
    );

    let valid = std::ecdsa_secp256k1::verify_signature(
        issuer_public_key_x,
        issuer_public_key_y,
        issuer_signature,
        claim_payload,
    );
    constrain valid == 1;
    valid == 1
}

//
// Tests
//

#[test]
fn test_construct_claim_payload() {
    let want = [0x2e, 0x22, 0x5d, 0x79, 0xe9, 0x49, 0xee, 0xc8, 0x50, 0x21, 0x1b, 0x5e, 0x73, 0x0f, 0xb9, 0xa8, 0x51, 0xc8, 0x82, 0x3b, 0x8f, 0x71, 0x69, 0x54, 0x39, 0x18, 0xea, 0x42, 0x47, 0xb6, 0x32, 0x57];
    let got = construct_claim_payload(1234567890, 2003, 1, 2);
    constrain want == got;

    // uncomment & inspect with: nargo test --show-output
    // std::println(got);
}

#[test]
fn test_valid_signature() {
    // Claim
    let subject = 1234567890;
    let subject_birthyear = 2003; 
    let subject_birthmonth = 1;
    let subject_birthday = 2;

    // Signature covering claim
    // This public key corresponds to private key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80 (1st one generated by anvil)
    let issuer_public_key_x: [u8; 32] = [0x83,0x18,0x53,0x5B,0x54,0x10,0x5D,0x4A,0x7A,0xAE,0x60,0xC0,0x8F,0xC4,0x5F,0x96,0x87,0x18,0x1B,0x4F,0xDF,0xC6,0x25,0xBD,0x1A,0x75,0x3F,0xA7,0x39,0x7F,0xED,0x75];
    let issuer_public_key_y: [u8; 32] = [0x35,0x47,0xF1,0x1C,0xA8,0x69,0x66,0x46,0xF2,0xF3,0xAC,0xB0,0x8E,0x31,0x01,0x6A,0xFA,0xC2,0x3E,0x63,0x0C,0x5D,0x11,0xF5,0x9F,0x61,0xFE,0xF5,0x7B,0x0D,0x2A,0xA5];
    let issuer_signature: [u8; 64] = [0x1e, 0x23, 0x61, 0x51, 0xe0, 0xce, 0x92, 0x96, 0x92, 0x4f, 0x67, 0x27, 0x70, 0xde, 0x88, 0xd3, 0x07, 0x46, 0xd8, 0x16, 0xab, 0xe2, 0xfb, 0x09, 0x4d, 0x46, 0x00, 0x52, 0x85, 0x44, 0xc3, 0x0c, 0x0e, 0x33, 0x72, 0xad, 0xd0, 0x02, 0x19, 0xc4, 0x68, 0x02, 0xb0, 0x91, 0x3d, 0x8b, 0xd0, 0xa0, 0xd6, 0xa9, 0xac, 0xca, 0xdb, 0xf1, 0x84, 0xd9, 0xf2, 0xce, 0xbc, 0x1c, 0x01, 0x94, 0x8d, 0x8f];

    let is_valid = main(
        2003,                   // required_birthyear
        1,                      // required_birthmonth
        3,                      // required_birthday
        issuer_public_key_x,
        issuer_public_key_y,
        issuer_signature,
        subject,
        subject_birthyear,
        subject_birthmonth,
        subject_birthday,
    );
    constrain is_valid == true;

    // HACK: The backend doesn't allow for creating proofs of invalid signatures, IIUC.
    //       Just uncomment this block to see it fail.
    //
    // let invalid_signature: [u8; 64] = [0; 64];
    // let expect_this_to_crash = main(
    //     2003,                   // required_birthyear
    //     1,                      // required_birthmonth
    //     2,                      // required_birthday
    //     issuer_public_key_x,
    //     issuer_public_key_y,
    //     invalid_signature,
    //     subject,
    //     subject_birthyear,
    //     subject_birthmonth,
    //     subject_birthday,
    // );
    // constrain expect_this_to_crash == false;
}
