use dep::std;

// Applies basic constraints such that the subject's birthdate is
// never after the required birthdate.
fn check_claim(
    required_birthyear: Field,
    required_birthmonth: Field,
    required_birthday: Field,
    subject_birthyear: Field,
    subject_birthmonth: Field,
    subject_birthday: Field,
) {
    assert(required_birthyear as u16 >= subject_birthyear as u16);
    if (required_birthyear == subject_birthyear) {
        assert(required_birthmonth as u8 >= subject_birthmonth as u8);
        if (required_birthmonth == subject_birthmonth) {
            assert(required_birthday as u8 >= subject_birthday as u8);
        }
    }
}

// Constructs a payload for the issuer to sign, claiming that
// the subject was born on the given date.
fn construct_claim_payload(
    subject: Field,
    birthyear: Field,
    birthmonth : Field,
    birthday : Field,
) -> [u8; 32] {
    let h1 = std::hash::pedersen([subject, birthyear, birthmonth, birthday])[0];
    let h2 = h1.to_be_bytes(32);
    let mut result = [0; 32];
    for i in 0..32 {
        result[i] = h2[i];
    }
    result
}

fn main(
    required_birthyear: pub Field,
    required_birthmonth: pub Field,
    required_birthday: pub Field,
    issuer_public_key_x: pub [u8; 32],
    issuer_public_key_y: pub [u8; 32],
    issuer_signature: [u8; 64],
    subject: pub Field,
    subject_birthyear: Field,
    subject_birthmonth: Field,
    subject_birthday: Field,
) -> pub bool {
    check_claim(
        required_birthyear,
        required_birthmonth,
        required_birthday,
        subject_birthyear,
        subject_birthmonth,
        subject_birthday,
    );

    let claim_payload = construct_claim_payload(
        subject,
        subject_birthyear,
        subject_birthmonth,
        subject_birthday,
    );

    let valid = std::ecdsa_secp256k1::verify_signature(
        issuer_public_key_x,
        issuer_public_key_y,
        issuer_signature,
        claim_payload,
    );
    assert(valid == true);
    valid
}

//
// Tests
//

#[test]
fn test_construct_claim_payload() {
    let want = [0x0b, 0xb7, 0xda, 0x0f, 0x91, 0x33, 0x82, 0x0c, 0xee, 0x8a, 0x9c, 0xe7, 0xda, 0x04, 0x1e, 0x22, 0x6a, 0x19, 0x12, 0xbe, 0xb5, 0x2b, 0x96, 0xa1, 0x41, 0x3e, 0xb7, 0x41, 0x15, 0xeb, 0x7a, 0xd7];
    let got = construct_claim_payload(1234567890, 2003, 1, 2);
    assert(want == got);

    // uncomment & inspect with: nargo test --show-output
    std::println(got);
}

#[test]
fn test_valid_signature() {
    // Claim
    let subject = 1234567890;
    let subject_birthyear = 2003; 
    let subject_birthmonth = 1;
    let subject_birthday = 2;

    // Signature covering claim
    // This public key corresponds to private key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80 (1st one generated by anvil)
    let issuer_public_key_x: [u8; 32] = [0x83,0x18,0x53,0x5B,0x54,0x10,0x5D,0x4A,0x7A,0xAE,0x60,0xC0,0x8F,0xC4,0x5F,0x96,0x87,0x18,0x1B,0x4F,0xDF,0xC6,0x25,0xBD,0x1A,0x75,0x3F,0xA7,0x39,0x7F,0xED,0x75];
    let issuer_public_key_y: [u8; 32] = [0x35,0x47,0xF1,0x1C,0xA8,0x69,0x66,0x46,0xF2,0xF3,0xAC,0xB0,0x8E,0x31,0x01,0x6A,0xFA,0xC2,0x3E,0x63,0x0C,0x5D,0x11,0xF5,0x9F,0x61,0xFE,0xF5,0x7B,0x0D,0x2A,0xA5];
    let issuer_signature: [u8; 64] = [0x88, 0xbb, 0x8d, 0x8e, 0x4d, 0x5f, 0x7e, 0x0a, 0x85, 0x3b, 0x5e, 0x4c, 0xda, 0xf3, 0x92, 0x24, 0x4d, 0x46, 0xf2, 0x2a, 0xdc, 0x0f, 0x4c, 0x28, 0x52, 0x7a, 0x28, 0xac, 0xf0, 0xa6, 0x2f, 0x3b, 0x1e, 0xf9, 0xfe, 0xbd, 0x3a, 0xde, 0xea, 0xed, 0x27, 0x6a, 0x32, 0x87, 0xe5, 0xdb, 0xf4, 0x32, 0x7a, 0x9c, 0x20, 0xce, 0xed, 0x40, 0x3e, 0xdb, 0xa5, 0x8d, 0xbd, 0xef, 0x01, 0xe6, 0x9b, 0xc6];

    let is_valid = main(
        2003,                   // required_birthyear
        1,                      // required_birthmonth
        3,                      // required_birthday
        issuer_public_key_x,
        issuer_public_key_y,
        issuer_signature,
        subject,
        subject_birthyear,
        subject_birthmonth,
        subject_birthday,
    );
    assert(is_valid == true);

    // HACK: The backend doesn't allow for creating proofs of invalid signatures, IIUC.
    //       Just uncomment this block to see it fail.
    //
    // let invalid_signature: [u8; 64] = [0; 64];
    // let expect_this_to_crash = main(
    //     2003,                   // required_birthyear
    //     1,                      // required_birthmonth
    //     2,                      // required_birthday
    //     issuer_public_key_x,
    //     issuer_public_key_y,
    //     invalid_signature,
    //     subject,
    //     subject_birthyear,
    //     subject_birthmonth,
    //     subject_birthday,
    // );
    // assert(expect_this_to_crash == false);
}
